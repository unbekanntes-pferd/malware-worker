import { HttpService } from '@nestjs/axios';
import { Logger } from '@nestjs/common';
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { RpcException } from '@nestjs/microservices';
import Vaas from "gdata-vaas";
import { Verdict } from 'gdata-vaas/lib/verdict';
import { catchError, lastValueFrom, map, Observable } from 'rxjs';
import { VaasAuthTokenResponse } from 'src/app.models';
import { NodeWebhookDto } from '../dtos/node-webhook.dto';
import { DownloadService } from '../download/download.service';

@Injectable()
export class VaasService {

    logger = new Logger('VaasService');
    vaas = new Vaas();
    vaasUrl: string;
    vaasTokenUrl: string;
    vaasClientId: string;
    vaasClientSecret: string;
    connectedMs: number | undefined;
    expiresIn = 0;
    connected = false;

    constructor(private readonly configService: ConfigService, private readonly downloadService: DownloadService,
        private readonly httpService: HttpService) {
        this.vaasTokenUrl = this.configService.get('dracoon.vaas.tokenUrl');
        this.vaasClientId = this.configService.get('dracoon.vaas.clientId');
        this.vaasClientSecret = this.configService.get('dracoon.vaas.clientSecret');
        this.vaasUrl = this.configService.get('dracoon.vaas.url');
    }

    async getVerdict(nodePayload: NodeWebhookDto) {

        // do not process files larger than max size
        if (this.exceedsMaxFileSize(nodePayload.payload.size)) {
            this.logger.log(`Max file size exceeded: size is ${nodePayload.payload.size}`);
            return;
        }

        const startTime = new Date().getTime();
        const nodeId = nodePayload.payload.id;


        // validate token 
        if (!this.connected || !this.isTokenValid) {

            await this.connectVaasClient();

        };

        // get download buffer
        let fileBuffer = await this.downloadService.downloadFile(nodeId);

        const startTimeAfterDownload = new Date().getTime();

        try {

            const verdict = await this.vaas.forFile(fileBuffer);

            this.logger.log(`Node id ${nodeId.toString()} scanned: ${verdict}`);

            if (verdict === Verdict.MALICIOUS) {

                this.logger.error(`Node id ${nodeId} identified as malicious.`);

            }

            // calculate verdict time
            const elapsedTime = new Date().getTime() - startTime;
            const elapsedTimeWithoutDownload = new Date().getTime() - startTimeAfterDownload;
            this.logger.debug(`Time to verdict: ${elapsedTime.toString()}`);
            this.logger.debug(`Time to verdict (no download): ${elapsedTimeWithoutDownload.toString()}`);

        } catch (e) {

            this.logger.error("Could not get verdict.");
            this.logger.debug(e);
            throw new RpcException(e);

        }

    }

    private getToken(): Observable<VaasAuthTokenResponse> {

        // x-www-urlencoded credentials for OAuth2 password flow
        const credentials = new URLSearchParams({
            grant_type: 'client_credentials',
            client_id: this.vaasClientId,
            client_secret: this.vaasClientSecret,
        });

        // axios request config
        const options = {
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
        };
        return this.httpService.post(this.vaasTokenUrl, credentials, options).pipe(
            catchError((e) => {
                this.logger.error('An error ocurred');
                this.logger.error(e);
                throw new RpcException(e);
            }),
            map((response) => response.data)
        );

    }

    private async connectVaasClient(): Promise<void> {

        this.connectedMs = new Date().getTime();
        const token = await lastValueFrom(this.getToken());
        await this.vaas.connect(token.access_token, this.vaasUrl);
        this.expiresIn = token.expires_in;
        this.connected = true;
        this.logger.log("Established new connection.");

    }

    private isTokenValid(): boolean {

        if (this.expiresIn === 0 || !this.connected || this.connectedMs === undefined) {
            this.logger.error("Token invalid (no connection) or expired.");
            return false;
        }

        const now = new Date().getTime();

        return this.connectedMs - now < this.expiresIn;

    }

    private exceedsMaxFileSize(size: number): boolean {

        return size > this.configService.get('dracoon.vaas.maxFileSize');

    }

}
